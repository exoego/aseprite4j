struct FileHeader {
  u32 fileSize;
  u16 magicNumber;
  if (magicNumber != 0xA5E0)
    continue;
  u16 frames;
  u16 widthInPixels;
  u16 heightInPixels;
  u16 colorDepth;
  u32 flags;
  u16 speed;
  u32 obsolete1;
  u32 obsolete2;
  u8 paletteEntryIndex;
  u8 ignore[3];
  u16 numberOfColors;
  u8 pixelWidth;
  u8 pixelHeight;
  s16 gridX;
  s16 gridY;
  u16 gridWidth;
  u16 gridHeight;
  u8 future[84];
};

struct ColorProfileChunk { //0x2007
  u16 type;
  u16 flags;
  float fixedGamma;
  u8 reserved[8];

  if (type == 0x2) {
    u32 iccProfileDataLength;
    u8  iccProfileData[iccProfileDataLength];
  }
};

struct FrameHeader {
  u32 bytesInFrame;
  u16 magicNumber;
  if (magicNumber != 0xF1FA)
    continue;
  u16 oldNumChunks;
  u16 frameDurationInMsec;
  u8 future[2];
  u32 newNumChunks;
};

struct OldColor {
  u8 red;
  u8 green;
  u8 blue;
};

struct OldPacket {
  u8 numberOfPalletEntriesToSkipFromLastPackage;
  u8 numberOfColors;
  OldColor colors[numberOfColors];
};

struct OldPalletteChunk {
  u16 numberOfPackets;
  OldPacket packets[numberOfPackets];
};

struct STRING {
  u16 length;
  u8 characters[length];
};
struct UUID {
  u8 characters[16];
};
struct TILE {
//* `TILE`: **Tilemaps**: Each tile can be a 8-bit (`BYTE`), 16-bit
//  (`WORD`), or 32-bit (`DWORD`) value and there are masks related to
//  the meaning of each bit.

};

struct LayerChunk {
/*
    WORD        Flags:
                  1 = Visible
                  2 = Editable
                  4 = Lock movement
                  8 = Background
                  16 = Prefer linked cels
                  32 = The layer group should be displayed collapsed
                  64 = The layer is a reference layer
*/
  u16 flags;
/*
    WORD        Layer type
                  0 = Normal (image) layer
                  1 = Group
                  2 = Tilemap
*/
  u16 layerType;
  u16 layerChildLevel;
  u16 defaultLayerWidth;
  u16 defaultLayerHeight;
  /*
    WORD        Blend mode (see NOTE.6)
                  Normal         = 0
                  Multiply       = 1
                  Screen         = 2
                  Overlay        = 3
                  Darken         = 4
                  Lighten        = 5
                  Color Dodge    = 6
                  Color Burn     = 7
                  Hard Light     = 8
                  Soft Light     = 9
                  Difference     = 10
                  Exclusion      = 11
                  Hue            = 12
                  Saturation     = 13
                  Color          = 14
                  Luminosity     = 15
                  Addition       = 16
                  Subtract       = 17
                  Divide         = 18*/
  u16 blendMode;

  u8 opacity;
  u8 future[3];

  STRING layerName;

  match(layerType) {
    (0x2): u16 tilesetIndex;
  }

  if (layerType & 0x4 != 0) {
     UUID layerUUID;
  }
};

struct PIXEL {
/*
   - **RGBA**: `BYTE[4]`, each pixel have 4 bytes in this order Red, Green, Blue, Alpha.
    - **Grayscale**: `BYTE[2]`, each pixel have 2 bytes in the order Value, Alpha.
    - **Indexed**: `BYTE`, each pixel uses 1 byte (the index).
*/
   u8 colorIndex;
};

struct CelChunk<auto Size> {
  u16 layerIndex;
  s16 xPos;
  s16 yPos;
  u8 opacityLevel;
/*    WORD        Cel Type
                0 - Raw Image Data (unused, compressed image is preferred)
                1 - Linked Cel
                2 - Compressed Image
                3 - Compressed Tilemap */
  u16 celType;

/*
    SHORT       Z-Index (see NOTE.5)
                0 = default layer ordering
                +N = show this cel N layers later
                -N = show this cel N layers back
*/
  s16 zIndex;

  u8 future[5];

  match(celType) {
    (0x0):  { // raw pixel cel
       u16 widthInPixels;
       u16 heightInPixels;
       PIXEL rawPixelData[];
     }
     (0x1): { // linked cel
        u16 framePosition;
     }
     (0x2): { // compressed image
       u16 widthInPixels;
       u16 heightInPixels;
       u8 ignore[2];
       u8 rawPixelData[Size - 16 - 6];
       // = builtin::hex::dec::zlib_decompress(PIXEL, Size - 16);
//       PIXEL rawPixelData[widthInPixels*heightInPixels];
     }
     (0x3): { // compressed tilemap
       u16 widthNumberTiles;
       u16 heightNumberTiles;
       u16 bitsPerTile;
       u32 bitmaskTileId;
       u32 bitmaskXFlip;
       u32 bitmaskYFlip;
       u32 bitmaskDiagonalFlip;
       u8 reserved[8];
       TILE rowByRow[];
     }
  }
};

struct CelExtraChunk {
};
struct ExternalFileChunk {
};
struct MaskChunk {
};
struct PathChunk {
};
struct TagsChunk {
};

struct PaletteEntry {
  u16 hasName;
  u8 r;
  u8 g;
  u8 b;
  u8 a;
  if (hasName & 0x1 != 0)
    STRING name;
};
struct PaletteChunk {
  u32 numberOfEntries;
  u32 start; // firstColorIndexToChange
  u32 end; // lastColorIndexToChange
  u8 reserved[8];

  PaletteEntry entries[end - start + 1];
};
struct UserDataChunk {
};
struct SliceChunk {
};
struct TilesetChunk {
};

struct FrameChunk {
  u32 chunkSize;
  u16 chunkType;

  match (chunkType) {
    (0x0004): OldPalletteChunk oldPalleteChunk;
    (0x2004): LayerChunk layerChunk;
    (0x2005): CelChunk<chunkSize - 6> celChunk;
    (0x2006): CelExtraChunk celExtraChunk;
    (0x2007): ColorProfileChunk colorProfileChunk;
    (0x2008): ExternalFileChunk externalFileChunk;
    (0x2016): MaskChunk maskChunk;
    (0x2017): PathChunk pathChunk;
    (0x2018): TagsChunk tagsChunk;
    (0x2019): PaletteChunk paletteChunk;
    (0x2020): UserDataChunk userDataChunk;
    (0x2022): SliceChunk sliceChunk;
    (0x2023): TilesetChunk tilesetChunk;
  }
};



struct Frame {
  FrameHeader header;
  FrameChunk chunk[header.newNumChunks];
};

struct Aseprite {
  FileHeader header;
  Frame frames[header.frames];
};

Aseprite Aseprite_at_0x00 @ 0x00;


//FileHeader fileheader_at_0x00 @ 0x00;
//FrameHeader frameheader_at_0x80 @ 0x80;
//FrameChunk framechunk_at_0x90 @ 0x90;
//FrameHeader frameheader_at_0x152 @ 0x152;
//FrameChunk framechunk_at_0x162 @ 0x162;